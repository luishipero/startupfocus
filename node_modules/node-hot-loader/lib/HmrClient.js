'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _LogColors = require('./LogColors');

var _LogColors2 = _interopRequireDefault(_LogColors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* globals __webpack_hash__ */

var HmrClient = function () {
  function HmrClient() {
    var _this = this;

    _classCallCheck(this, HmrClient);

    Object.defineProperty(this, 'defaultListener', {
      enumerable: true,
      writable: true,
      value: function value(message) {
        // webpackHotUpdate
        if (message.action === 'built') {
          _this.lastHash = message.stats.hash;
          if (!_this.upToDate()) {
            var status = module.hot.status();
            if (status === 'idle') {
              console.log(HmrClient.logPrefix, 'Checking for updates on the server...');
              _this.check();
            } else if (['abort', 'fail'].indexOf(status) >= 0) {
              console.warn(HmrClient.logPrefix, 'Cannot apply update as a previous update ' + status + 'ed. Need to do a full reload!');
            }
          }
        }
      }
    });
    Object.defineProperty(this, 'upToDate', {
      enumerable: true,
      writable: true,
      value: function value() {
        return _this.lastHash.indexOf(__webpack_hash__) >= 0;
      }
    });
    Object.defineProperty(this, 'check', {
      enumerable: true,
      writable: true,
      value: function value() {
        module.hot.check().then(function (updatedModules) {
          if (!updatedModules) {
            console.warn(HmrClient.logPrefix, 'Cannot find update. Need to do a full reload!');
            console.warn(HmrClient.logPrefix, '(Probably because of restarting the webpack-dev-server)');
            return;
          }

          return module.hot.apply({
            ignoreUnaccepted: true,
            ignoreDeclined: true,
            ignoreErrored: true,
            onUnaccepted: function onUnaccepted(data) {
              console.warn('Ignored an update to unaccepted module ' + data.chain.join(' -> '));
            },
            onDeclined: function onDeclined(data) {
              console.warn('Ignored an update to declined module ' + data.chain.join(' -> '));
            },
            onErrored: function onErrored(data) {
              console.warn('Ignored an error while updating module ' + data.moduleId + ' (' + data.type + ')');
            }
          }).then(function (renewedModules) {
            if (!_this.upToDate()) {
              _this.check();
            }

            HmrClient.logApplyResult(updatedModules, renewedModules);

            if (_this.upToDate()) {
              console.log(HmrClient.logPrefix, 'App is up to date.');
            }
          });
        }).catch(function (err) {
          var status = module.hot.status();
          if (['abort', 'fail'].indexOf(status) >= 0) {
            console.warn(HmrClient.logPrefix, 'Cannot check for update. Need to do a full reload!');
            console.warn(HmrClient.logPrefix, err.stack || err.message);
          } else {
            console.warn(HmrClient.logPrefix, 'Update check failed: ' + err.stack || err.message);
          }
        });
      }
    });
  }

  _createClass(HmrClient, [{
    key: 'run',
    value: function run() {
      var listener = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.defaultListener;

      if (!module.hot) {
        throw new Error(HmrClient.logPrefix, 'Hot Module Replacement is disabled.');
      }

      console.log(HmrClient.logPrefix, 'Waiting for update signal from WDS...');
      process.on('message', listener);
      return this;
    }
  }], [{
    key: 'logApplyResult',
    value: function logApplyResult(updatedModules, renewedModules) {
      var unacceptedModules = updatedModules.filter(function (moduleId) {
        return renewedModules && renewedModules.indexOf(moduleId) < 0;
      });

      if (unacceptedModules.length > 0) {
        console.warn(HmrClient.logPrefix, "The following modules couldn't be hot updated: (They would need a full reload!)");
        unacceptedModules.forEach(function (moduleId) {
          console.warn(HmrClient.logPrefix, ' - ' + moduleId);
        });
      }

      if (!renewedModules || renewedModules.length === 0) {
        console.log(HmrClient.logPrefix, 'Nothing hot updated.');
      } else {
        console.log(HmrClient.logPrefix, 'Updated modules:');
        renewedModules.forEach(function (moduleId) {
          console.log(HmrClient.logPrefix, ' - ' + moduleId);
        });
        var numberIds = renewedModules.every(function (moduleId) {
          return typeof moduleId === 'number';
        });
        if (numberIds) {
          console.log(HmrClient.logPrefix, 'Consider using the NamedModulesPlugin for module names.');
        }
      }
    }
  }]);

  return HmrClient;
}();

Object.defineProperty(HmrClient, 'logPrefix', {
  enumerable: true,
  writable: true,
  value: _LogColors2.default.cyan('[HMR]')
});
exports.default = new HmrClient().run();